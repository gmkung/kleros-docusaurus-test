---
id: erc-792
title: ERC-792 Arbitration Standard
sidebar_label: ERC-792
description: Implementation guide for the ERC-792 arbitration standard
---

# ERC-792 Arbitration Standard

The ERC-792 standard defines how smart contracts can integrate with arbitration systems for decentralized dispute resolution.

## Overview

ERC-792 provides a standardized interface for smart contracts to request arbitration and receive rulings from decentralized arbitration systems like Kleros.

## Interface

```solidity
interface IArbitrable {
    function rule(uint256 _disputeID, uint256 _ruling) external;
}

interface IArbitrator {
    function createDispute(uint256 _choices, bytes calldata _extraData) external payable returns (uint256 disputeID);
    function appeal(uint256 _disputeID, bytes calldata _extraData) external payable;
    function appealPeriod(uint256 _disputeID) external view returns (uint256 begin, uint256 end);
    function appealCost(uint256 _disputeID) external view returns (uint256 cost);
    function currentRuling(uint256 _disputeID) external view returns (uint256 ruling);
    function disputeStatus(uint256 _disputeID) external view returns (DisputeStatus status);
    function isDispute(uint256 _disputeID) external view returns (bool);
}
```

## Implementation

### Basic Arbitrable Contract

```solidity
contract MyArbitrableContract is IArbitrable {
    IArbitrator public arbitrator;
    uint256 public disputeID;
    uint256 public ruling;
    
    event DisputeCreated(uint256 indexed disputeID, bytes evidence);
    event RulingReceived(uint256 indexed disputeID, uint256 ruling);
    
    constructor(address _arbitrator) {
        arbitrator = IArbitrator(_arbitrator);
    }
    
    function createDispute(bytes calldata _evidence) external payable {
        require(msg.value >= arbitrator.arbitrationCost(_evidence), "Insufficient fee");
        
        disputeID = arbitrator.createDispute{value: msg.value}(_evidence);
        
        emit DisputeCreated(disputeID, _evidence);
    }
    
    function rule(uint256 _disputeID, uint256 _ruling) external override {
        require(msg.sender == address(arbitrator), "Only arbitrator");
        require(_disputeID == disputeID, "Invalid dispute ID");
        
        ruling = _ruling;
        
        emit RulingReceived(_disputeID, _ruling);
        
        // Handle the ruling based on your contract logic
        handleRuling(_ruling);
    }
    
    function handleRuling(uint256 _ruling) internal {
        // Implement your ruling handling logic here
        if (_ruling == 1) {
            // Handle ruling 1
        } else if (_ruling == 2) {
            // Handle ruling 2
        }
        // Add more ruling cases as needed
    }
}
```

### Advanced Implementation with Evidence

```solidity
contract AdvancedArbitrableContract is IArbitrable {
    IArbitrator public arbitrator;
    mapping(uint256 => Dispute) public disputes;
    
    struct Dispute {
        uint256 disputeID;
        address initiator;
        bytes evidence;
        uint256 ruling;
        bool resolved;
        uint256 timestamp;
    }
    
    event DisputeCreated(uint256 indexed disputeID, address indexed initiator, bytes evidence);
    event EvidenceSubmitted(uint256 indexed disputeID, address indexed submitter, bytes evidence);
    event RulingReceived(uint256 indexed disputeID, uint256 ruling);
    
    constructor(address _arbitrator) {
        arbitrator = IArbitrator(_arbitrator);
    }
    
    function createDispute(bytes calldata _evidence) external payable {
        uint256 cost = arbitrator.arbitrationCost(_evidence);
        require(msg.value >= cost, "Insufficient fee");
        
        uint256 disputeID = arbitrator.createDispute{value: cost}(_evidence);
        
        disputes[disputeID] = Dispute({
            disputeID: disputeID,
            initiator: msg.sender,
            evidence: _evidence,
            ruling: 0,
            resolved: false,
            timestamp: block.timestamp
        });
        
        // Refund excess payment
        if (msg.value > cost) {
            payable(msg.sender).transfer(msg.value - cost);
        }
        
        emit DisputeCreated(disputeID, msg.sender, _evidence);
    }
    
    function submitEvidence(uint256 _disputeID, bytes calldata _evidence) external {
        require(disputes[_disputeID].disputeID != 0, "Dispute does not exist");
        require(!disputes[_disputeID].resolved, "Dispute already resolved");
        
        // Store additional evidence
        // Note: This is a simplified implementation
        // In production, you might want to use IPFS or other storage solutions
        
        emit EvidenceSubmitted(_disputeID, msg.sender, _evidence);
    }
    
    function rule(uint256 _disputeID, uint256 _ruling) external override {
        require(msg.sender == address(arbitrator), "Only arbitrator");
        require(disputes[_disputeID].disputeID != 0, "Dispute does not exist");
        require(!disputes[_disputeID].resolved, "Dispute already resolved");
        
        disputes[_disputeID].ruling = _ruling;
        disputes[_disputeID].resolved = true;
        
        emit RulingReceived(_disputeID, _ruling);
        
        handleRuling(_disputeID, _ruling);
    }
    
    function handleRuling(uint256 _disputeID, uint256 _ruling) internal {
        // Implement your ruling handling logic here
        // This could include:
        // - Releasing funds
        // - Changing contract state
        // - Triggering other actions
    }
    
    function getDispute(uint256 _disputeID) external view returns (Dispute memory) {
        return disputes[_disputeID];
    }
}
```

## Integration with Kleros

### Setting up the Arbitrator

```solidity
contract KlerosArbitrator is IArbitrator {
    // Kleros-specific implementation
    // This would integrate with the actual Kleros court system
}
```

### Using Kleros Court

```solidity
contract KlerosIntegration {
    IArbitrator public klerosArbitrator;
    
    constructor(address _klerosArbitrator) {
        klerosArbitrator = IArbitrator(_klerosArbitrator);
    }
    
    function createKlerosDispute(bytes calldata _evidence) external payable {
        // Create dispute in Kleros court
        uint256 disputeID = klerosArbitrator.createDispute{value: msg.value}(_evidence);
        
        // Handle dispute creation
    }
}
```

## Best Practices

1. **Gas Optimization**: Minimize gas costs in dispute creation and ruling handling
2. **Security**: Implement proper access controls and validation
3. **Error Handling**: Handle edge cases and errors gracefully
4. **Testing**: Thoroughly test with different dispute scenarios
5. **Documentation**: Document your implementation clearly

## Testing

```solidity
contract ArbitrableTest {
    function testDisputeCreation() public {
        // Test dispute creation
    }
    
    function testRulingHandling() public {
        // Test ruling handling
    }
    
    function testEvidenceSubmission() public {
        // Test evidence submission
    }
}
```

## Deployment

1. Deploy your arbitrable contract
2. Set the arbitrator address
3. Test the integration
4. Monitor for any issues

## Support

For ERC-792 implementation support:
- [Kleros Developer Documentation](/docs/developers)
- [GitHub Repository](https://github.com/kleros/kleros-contracts)
- [Developer Discord](https://discord.gg/kleros)
